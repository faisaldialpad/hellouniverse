# Problem Set

## Other Problem Sets
* https://github.com/rfaisal/hellouniverse/blob/master/ProblemSet-Arrays-ArrayLists.md
* https://github.com/rfaisal/hellouniverse/blob/master/ProblemSet-Bitwise-Math.md
* https://github.com/rfaisal/hellouniverse/blob/master/ProblemSet-Dynamic-Programming.md
* https://github.com/rfaisal/hellouniverse/blob/master/ProblemSet-Others.md
* https://github.com/rfaisal/hellouniverse/blob/master/ProblemSet-String.md
* https://github.com/rfaisal/hellouniverse/blob/master/ProblemSet-Trees-Graphs.md

## LinkedLists
1. Implement a singly linked list with `add(int v, int pos)`, `remove(int pos)`, and `print()` functionalities. Write a function to remove a linked list node when you only have access to that node. 
    * Link: 
    * Solutions: https://github.com/rfaisal/hellouniverse/blob/master/C/linkedlists/singly__add__remove__remove_without_head.c
2. How will you detect a corrupt singly linked list (a linked list that has a circle in it, i.e., an arbitrary node's next pointer points to an earlier node)? 
    * Link: 
    * Solutions: https://github.com/rfaisal/hellouniverse/blob/master/Java/src/linkedlists/CircularList.java
3. Return the starting node of a circle and null if it is not circular. 
    * Link: 
    * Solutions: https://github.com/rfaisal/hellouniverse/blob/master/Java/src/linkedlists/CircularList.java
4. Write a function that will return true if a circular singly linked list has duplicate values and false if there are no duplicate values or the linked list is not circular. You can assume that the values are ascii characters ranging from 0 to 127. 
    * Link: 
    * Solutions: https://github.com/rfaisal/hellouniverse/blob/master/Java/src/linkedlists/CircularList.java
5. Add 2 numbers represented by linked lists: each node contains a digit and the digits are reverse order. For example: 123 is represented by 3->2->1 and 905 is represented by 5->0->9 and their addition will be 8->2->0->1 i.e., 1028. You are allowed to traverse each list only once. 
    * Link: 
    * Solutions: https://github.com/rfaisal/hellouniverse/blob/master/Java/src/linkedlists/LinkedListAdd.java
6. Implement an algorithm to find the last n elements of a singly linked list. 
    * Link: 
    * Solutions: https://github.com/rfaisal/hellouniverse/blob/master/Java/src/linkedlists/Last_N_Elements.java
7. Suppose a weird singly linked list has a child pointer that can point to a Node i.e., another linked list (which also has a child pointer). Flatten the list. (if a node has a child then the after flatten, the child's last node should point to current's next node and current's next node should point to its child. Remember the child should also be recursively flattened.). 
    * Link: 
    * Solutions: https://github.com/rfaisal/hellouniverse/blob/master/Java/src/linkedlists/FlattenListWithChild.java
8. Write an algorithm to remove duplicates from an unsorted linked list.  [unit tests are coming]
    * Link: 
    * Solutions: https://github.com/rfaisal/hellouniverse/blob/master/Java/src/linkedlists/RemoveDuplicates.java
9. Write a program that checks if 2 singly linkedlists intersect or not. You can assume both of the lists does not have any cycle. 
    * Link: 
    * Solutions: https://github.com/rfaisal/hellouniverse/blob/master/Java/src/linkedlists/IntersectingLinkedList.java
10. Write a program that returns the intersecting node of 2 singly linkedlists and null otherwise. You can assume both of the lists does not have any cycle. 
    * Link: 
    * Solutions: https://github.com/rfaisal/hellouniverse/blob/master/Java/src/linkedlists/IntersectingLinkedList.java
11. Reverse a linked list.
    * Link: 
    * Solutions: https://github.com/rfaisal/hellouniverse/blob/master/Java/src/linkedlists/ReverseList.java
    
[![Bitdeli Badge](https://d2weczhvl823v0.cloudfront.net/rfaisal/hellouniverse/trend.png)](https://bitdeli.com/free "Bitdeli Badge")
